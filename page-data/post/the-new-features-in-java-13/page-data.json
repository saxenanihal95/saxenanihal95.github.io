{"componentChunkName":"component---src-templates-blog-post-js","path":"/post/the-new-features-in-java-13","result":{"data":{"wordpressPost":{"title":"The New Features In Java 13","content":"\n<p>This year has\nwitnessed two versions of Java. Java 13 is released on September 17th, 2019\nwith lots of new features. Among them, ten remarkable features are discussed\nbelow: </p>\n\n\n\n\n\n<ol><h5><strong><li>JEP\n350 Dynamic CDS Archives</strong></li></h5>\n\n\n\n<p></p>\n\n\n\n<p>It started the journey in Java 10 and\nstreamlined the process of the CDS (Class Data Sharing) archive creation.\nHowever, the creation of the CDS archives depends on the existence of the program\nwith <code>-XX:ArchiveClassesAtExit</code><code>.</code></p>\n\n\n\n<p>The good news is that JEP (JDK Enhancement Proposal) has come with the improved version of the JEP 310 Application Class-Data Sharing. </p>\n\n\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\">$ java -XX:ArchiveClassesAtExit=hello.jsa -cp hello.jar Hello</pre>\n\n\n\n<p>The code below\nis for running the program with the CDS\narchives specified above. </p>\n\n\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\">$  bin/java -XX:SharedArchiveFile=hello.jsa -cp hello.jar Hello</pre>\n\n\n\n<p>The main goal of CDS is to enhance the performance\nof start-ups through the creation of a class-data archive for only once and it’s\nfollowed by reusing it. Thus, the need of recreation by JVM (Java virtual\nmachine) can be eliminated. </p>\n\n\n\n<h5><li><strong>Reimplementation\nOf Legacy Socket API Is Done By JEP-353</strong></li></h5>\n\n\n\n<p></p>\n\n\n\n<p>The concepts of <code>java.net.ServerSocket and java.net.Socket implementations belong to </code>JDK 1.0. That means it’s almost outdated nowadays. Since it’s a combination of Java and C code, it’s really difficult to debug as well as maintain. </p>\n\n\n\n<p>However, the JEP has come with new basic implementations\ndedicated to the Socket APIs. It is actually the default implementation of this\nversion. </p>\n\n\n\n<p>In previous versions, it used the <code>PlainSocketImpl</code> for the <code>SocketImpl.</code></p>\n\n\n\n<p>ServerSocket.java<code> </code></p>\n\n\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\">public class ServerSocket implements java.io.Closeable {\n\n    /**\n\n     * The implementation of this Socket.\n\n     */\n\n    private SocketImpl impl;\n\n}</pre>\n\n\n\n<h5><li><strong>JEP-354\nSwitch Expressions (Preview)</strong></li></h5>\n\n\n\n<p></p>\n\n\n\n<p>The JEP- in this version- improved the last Java 12 JEP 325 Switch expressions. Thus, it can now be used as either an expression (for returning something) or a statement (for NOT returning something). Furthermore, a new keyword ‘yield’ also started its journey for returning a value from the switch statement. </p>\n\n\n\n<p>When it comes to (PlainSocketImpl)’s drop-in replacement, Java 13 has\nlaunched a new NioSocketImpl class. </p>\n\n\n\n<p>Let’s take a look at a Socket example below:</p>\n\n\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\">import java.io.IOException;\n\nimport java.net.ServerSocket;\n\nimport java.net.Socket;\n\npublic class JEP353 {\n\n    public static void main(String[] args) {\n\n        try (ServerSocket serverSocket = new ServerSocket(8888)) {\n\n            boolean running = true;\n\n            while (running) {\n\n                Socket clientSocket = serverSocket.accept();\n\n                //do something with clientSocket\n\n            }\n\n        } catch (IOException e) {\n\n            e.printStackTrace();\n\n        }\n\n    }\n\n}</pre>\n\n\n\n<h5><li><strong>JEP-355\nText Blocks (Preview)</strong></li></h5>\n\n\n\n<p></p>\n\n\n\n<p><em>This </em>JDK Enhancement Proposal has also launched multi-line string literal, which is a text block. It is actually a <em>preview language feature in this Java version. </em></p>\n\n\n\n<p>Prior to Java 12, programmers can return a value with traditional <code>switch</code> statement as follows: </p>\n\n\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\">private static String getText(int number) {\n    String result = \"\";\n    switch (number) {\n        case 1:\n            result = \"one\";\n            break;\n        case 2:\n            result = \"two\";\n            break;\n        case 3:\n            result = \"three\";\n            break;\n        default:\n            result = \"unknown\";\n            break;\n    };\n    return result;\n}</pre>\n\n\n\n<p>After the introduction of Java 12, programmers used to take help\nof <code>break in order to return a value\nfrom a switch. </code></p>\n\n\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\">private static String getText(int number) {\n    String result =\n        switch (number) {\n            case 1:\n                break \"one\";\n            case 2:\n                break \"two\";\n            case 3:\n                break \"three\";\n            default:\n                break \"unknown\";\n        };\n    return result;\n}</pre>\n\n\n\n<p>Now, in Java 13, <code>yield\nis introduced for returning a value. </code></p>\n\n\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\">private static String getText(int number) {\n    return switch (number) {\n        case 1:\n            yield \"one\";\n        case 2:\n            yield \"two\";\n        case 3:\n            yield \"three\";\n        default:\n            yield \"unknown\";\n    };\n}</pre>\n\n\n\n<h5><li><strong>Java 13 Supports For </strong><strong>Unicode 12.1&nbsp;</strong> </li></h5>\n\n\n\n<p>The new version has upgraded Unicode support to 12.1 that includes the changes below:</p>\n\n\n\n<p>java.lang.Character\nis compatible with Unicode Character Database of the level of 12.1.</p>\n\n\n\n<p>java.util.regex\npackage aids Extended Grapheme Clusters that depends on 12.0 level of Unicode\nStandard Annex #29. </p>\n\n\n\n<p>java.text.Normalizer\nand java.text.Bidi classes support Unicode of 12.0 level Unicode Standard\nAnnexes, number 9 and number 15, respectively. </p>\n\n\n\n<h5><li><strong>New String Constants\nAre Introduced For Canonical XML 1.1 URIs</strong>&nbsp;</li></h5>\n\n\n\n<p>INCLUSIVE_11 and INCLUSIVE_11_WITH_COMMENTS are two New\nString constants and they are added to the javax.xml.crypto.dsig.CanonicalizationMethod\nAPI. </p>\n\n\n\n<h5><li><strong>This Version Permits The Restriction Of </strong><strong>SASL Mechanisms</strong></li></h5>\n\n\n\n<p>Java 13 has added a security property, called jdk.sasl.disabledMechanisms\nand it can deactivate SASL mechanisms. Moreover, any deactivated mechanism would be\nignored in case it’s described in the mechanisms argument of Sasl.createSaslServer\nor the mechanisms argument of Sasl.createSaslClient. </p>\n\n\n\n<h5><li><strong>A Default Native\nGSS-API Library on Windows&nbsp;Has Been Added</strong></li></h5>\n\n\n\n<p>This version of Java has added a native GSS-API library\nto JDK on Windows. Nonetheless, the library is only client-side and it makes\nuse of the default credentials. Once the property, sun.security.jgss.native\nsystem gets set to &#8220;true&#8221;, the GSS-API library will be loaded. </p>\n\n\n\n<h5><li><strong>Kerberos Cross-Realm Referrals (RFC 6806)</strong>&nbsp;<strong>Is Supported</strong><strong></strong></li></h5>\n\n\n\n<p>Cross-realm referrals and principal name\ncanonicalization support the Kerberos client for its improvement. The RFC 6806\nprotocol extension has defined this rule. </p>\n\n\n\n<h5><li><strong>Runtime Trace Methods</strong>&nbsp;<strong>Have Been</strong>\n<strong>Removed</strong></li></h5>\n\n\n\n<p>The methods, traceMethodCalls(boolean) and traceInstructions(boolean)\nhave become outdated. So, in Java 13, these two methods are eliminated from the\njava.lang.Runtime class. </p>\n\n\n\n<p>It’s not a comprehensive list. A lot of other features\nhave also been introduced in Java 13. </p>\n","excerpt":"<p>This year has witnessed two versions of Java. Java 13 is released on September 17th, 2019 with lots of new features. Among them, ten remarkable features are discussed below: JEP<a href=\"http://www.psycoderblog.com/the-new-features-in-java-13/\" class=\"more-link\"><span class=\"readmore\">Continue reading<span class=\"screen-reader-text\">The New Features In Java 13</span></span></a></p>\n","date":"October 23, 2019","author":{"name":"Puja Majumder"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":733}}}